{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _v = _interopRequireDefault(require(\"uuid/v4\"));\n\nvar utils = _interopRequireWildcard(require(\"./utils/utils\"));\n\nvar _options = _interopRequireDefault(require(\"./utils/options\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar ReactFC =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ReactFC, _React$Component);\n\n  _createClass(ReactFC, null, [{\n    key: \"fcRoot\",\n    value: function fcRoot(core) {\n      for (var _len = arguments.length, modules = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        modules[_key - 1] = arguments[_key];\n      }\n\n      modules.forEach(function (m) {\n        if (m.getName && m.getType || m.name && m.type) {\n          core.addDep(m);\n        } else {\n          m(core);\n        }\n      });\n      ReactFC.fusionChartsCore = core;\n    }\n  }]);\n\n  function ReactFC(props) {\n    var _this;\n\n    _classCallCheck(this, ReactFC);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactFC).call(this, props));\n    _this.containerId = (0, _v[\"default\"])();\n    _this.oldOptions = null;\n    _this.FusionCharts = props.fcLibrary || ReactFC.fusionChartsCore;\n    return _this;\n  }\n\n  _createClass(ReactFC, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.renderChart();\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (!this.oldOptions) {\n        return;\n      }\n\n      this.detectChanges(nextProps);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.chartObj.dispose();\n    }\n  }, {\n    key: \"detectChanges\",\n    value: function detectChanges(nextProps) {\n      var currentOptions = this.resolveChartOptions(nextProps);\n      var oldOptions = this.oldOptions;\n      var optionsUpdatedNatively = ['width', 'height', 'type', 'dataFormat', 'dataSource', 'events'];\n      this.checkAndUpdateChartDimensions(currentOptions, oldOptions);\n      this.checkAndUpdateChartType(currentOptions, oldOptions);\n      this.checkAndUpdateChartData(currentOptions, oldOptions);\n      this.checkAndUpdateEvents(currentOptions, oldOptions);\n      this.checkAndUpdateRestOptions(_options[\"default\"].filter(function (option) {\n        return optionsUpdatedNatively.indexOf(option) === -1;\n      }), currentOptions, oldOptions);\n      this.oldOptions = currentOptions;\n    }\n  }, {\n    key: \"checkAndUpdateChartDimensions\",\n    value: function checkAndUpdateChartDimensions(currentOptions, oldOptions) {\n      var currWidth = currentOptions.width;\n      var currHeight = currentOptions.height;\n      var oldWidth = oldOptions.width;\n      var oldHeight = oldOptions.height;\n\n      if (String(currWidth) !== String(oldWidth) || String(currHeight) !== String(oldHeight)) {\n        if (!utils.isUndefined(currWidth) && !utils.isUndefined(currHeight)) {\n          this.chartObj.resizeTo(currWidth, currHeight);\n        } else {\n          if (!utils.isUndefined(currWidth)) {\n            this.chartObj.resizeTo({\n              w: currWidth\n            });\n          }\n\n          if (!utils.isUndefined(currHeight)) {\n            this.chartObj.resizeTo({\n              h: currHeight\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"checkAndUpdateChartType\",\n    value: function checkAndUpdateChartType(currentOptions, oldOptions) {\n      var currType = currentOptions.type;\n      var oldType = oldOptions.type;\n\n      if (String(currType).toLowerCase() !== String(oldType).toLowerCase()) {\n        if (!utils.isUndefined(currType)) {\n          this.chartObj.chartType(String(currType).toLowerCase());\n        }\n      }\n    }\n  }, {\n    key: \"checkAndUpdateChartData\",\n    value: function checkAndUpdateChartData(currentOptions, oldOptions) {\n      var currDataFormat = currentOptions.dataFormat;\n      var currData = currentOptions.dataSource;\n      var oldDataFormat = oldOptions.dataFormat;\n      var oldData = oldOptions.dataSource;\n\n      if (String(currDataFormat).toLowerCase() !== String(oldDataFormat).toLowerCase()) {\n        if (!utils.isUndefined(currDataFormat) && !utils.isUndefined(currData)) {\n          this.chartObj.setChartData(currData, String(currDataFormat).toLowerCase()); // If the chart dataFormat is changed then\n          // animate the chart to show the changes\n\n          this.chartObj.render();\n          return;\n        }\n      }\n\n      if (!this.isSameChartData(currData, oldData)) {\n        if (!utils.isUndefined(currData)) {\n          this.chartObj.setChartData(currData, // When dataFormat is not given, but data is changed,\n          // then use 'json' as default dataFormat\n          currDataFormat ? String(currDataFormat).toLowerCase() : 'json');\n        }\n      }\n    }\n  }, {\n    key: \"isSameChartData\",\n    value: function isSameChartData(currData, oldData) {\n      /* TODO\n        1. Current has DataStore and Old doesn't\n        2. Old has and Current doesn't\n        3. Both has, check ref is equal, return false only if not equal\n        4. Clone oldData for diff\n        5. Clone currentData for diff\n        6. return string check.\n      */\n      // 1. Current has DataStore and Old doesn't\n      if (utils.checkIfDataTableExists(currData) && !utils.checkIfDataTableExists(oldData)) {\n        return false;\n      } // 2. Old has and Current doesn't\n\n\n      if (!utils.checkIfDataTableExists(currData) && utils.checkIfDataTableExists(oldData)) {\n        return false;\n      } // 3. Both has, check ref is equal, return false only if not equal\n\n\n      if (utils.checkIfDataTableExists(currData) && utils.checkIfDataTableExists(oldData) && currData.data !== oldData.data) {\n        return false;\n      } // 4. Clone oldData for diff\n\n\n      var oldDataStringified = JSON.stringify(utils.cloneDataSource(oldData, 'diff')); // 5. Clone currentData for diff\n\n      var currentDataStringified = JSON.stringify(utils.cloneDataSource(currData, 'diff')); // 6. return string check.\n\n      return oldDataStringified === currentDataStringified;\n    }\n  }, {\n    key: \"checkAndUpdateEvents\",\n    value: function checkAndUpdateEvents(currentOptions, oldOptions) {\n      var _this2 = this;\n\n      var currEvents = currentOptions.events;\n      var oldEvents = oldOptions.events;\n      var temp1;\n      var temp2;\n\n      if (this.detectChartEventsChange(currEvents, oldEvents)) {\n        if (!utils.isUndefined(currEvents)) {\n          temp1 = Object.assign({}, currEvents);\n          temp2 = utils.isUndefined(oldEvents) ? {} : Object.assign({}, oldEvents);\n          Object.keys(temp2).forEach(function (eventName) {\n            if (temp2[eventName] === temp1[eventName]) {\n              temp1[eventName] = undefined;\n            } else {\n              _this2.chartObj.removeEventListener(eventName, temp2[eventName]);\n            }\n          });\n          Object.keys(temp1).forEach(function (eventName) {\n            if (temp1[eventName]) {\n              _this2.chartObj.addEventListener(eventName, temp1[eventName]);\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"detectChartEventsChange\",\n    value: function detectChartEventsChange(currEvents, oldEvents) {\n      if (utils.isObject(currEvents) && utils.isObject(oldEvents)) {\n        return !this.isSameChartEvents(currEvents, oldEvents);\n      }\n\n      return !(currEvents === oldEvents);\n    }\n  }, {\n    key: \"isSameChartEvents\",\n    value: function isSameChartEvents(currEvents, oldEvents) {\n      if (Object.keys(currEvents).length !== Object.keys(oldEvents).length) {\n        return false;\n      }\n\n      var currEventNames = Object.keys(currEvents);\n\n      for (var i = 0; i < currEventNames.length; ++i) {\n        var evName = currEventNames[i];\n\n        if (currEvents[evName] !== oldEvents[evName]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"checkAndUpdateRestOptions\",\n    value: function checkAndUpdateRestOptions(restOptions, currentOptions, oldOptions) {\n      var _this3 = this;\n\n      var optionsUpdated = false;\n      restOptions.forEach(function (optionName) {\n        var currValue = currentOptions[optionName];\n        var oldValue = oldOptions[optionName];\n\n        if (!_this3.isSameOptionValue(currValue, oldValue)) {\n          if (!utils.isUndefined(currValue)) {\n            if (_this3.chartObj.options && _this3.chartObj.options.hasOwnProperty(optionName)) {\n              _this3.chartObj.options[optionName] = currValue;\n              optionsUpdated = true;\n            }\n          }\n        }\n      });\n\n      if (optionsUpdated) {\n        this.chartObj.render(); // re-render the chart to reflect the changes\n      }\n    }\n  }, {\n    key: \"isSameOptionValue\",\n    value: function isSameOptionValue(currValue, oldValue) {\n      if (utils.isObject(currValue) && utils.isObject(oldValue)) {\n        return utils.isSameObjectContent(currValue, oldValue);\n      }\n\n      return String(currValue) === String(oldValue);\n    }\n  }, {\n    key: \"renderChart\",\n    value: function renderChart() {\n      var _this4 = this;\n\n      var currentOptions = this.resolveChartOptions(this.props);\n      var events = {};\n      currentOptions.renderAt = this.containerId;\n      Object.keys(this.props).forEach(function (value) {\n        var event = value.match(/^fcEvent-.*/i);\n\n        if (event && typeof _this4.props[value] === 'function') {\n          var eventName = value.replace(/^fcEvent-/i, '');\n          events[eventName] = _this4.props[value];\n        }\n      });\n\n      if (Object.keys(events).length > 0) {\n        if (currentOptions.events === undefined) {\n          currentOptions.events = events;\n        } else {\n          currentOptions.events = Object.assign(currentOptions.events, events);\n        }\n      }\n\n      this.chartObj = new this.FusionCharts(currentOptions);\n      this.chartObj.render();\n      this.oldOptions = currentOptions;\n\n      if (this.props.onRender && typeof this.props.onRender === 'function') {\n        this.props.onRender(this.chartObj);\n      }\n    }\n  }, {\n    key: \"resolveChartOptions\",\n    value: function resolveChartOptions(props) {\n      var chartConfig = props.chartConfig ? props.chartConfig : {};\n\n      var inlineOptions = _options[\"default\"].reduce(function (options, optionName) {\n        options[optionName] = props[optionName];\n        return options;\n      }, {});\n\n      Object.assign(inlineOptions, chartConfig);\n\n      if (utils.isObject(inlineOptions.dataSource) && !utils.checkIfDataTableExists(inlineOptions.dataSource)) {\n        inlineOptions.dataSource = utils.deepCopyOf(inlineOptions.dataSource);\n      } else if (utils.isObject(inlineOptions.dataSource) && utils.checkIfDataTableExists(inlineOptions.dataSource)) {\n        inlineOptions.dataSource = utils.cloneDataSource(inlineOptions.dataSource, 'clone');\n      }\n\n      if (utils.isObject(inlineOptions.link)) {\n        inlineOptions.link = utils.deepCopyOf(inlineOptions.link);\n      }\n\n      if (utils.isObject(inlineOptions.events)) {\n        inlineOptions.events = Object.assign({}, inlineOptions.events);\n      }\n\n      return inlineOptions;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react[\"default\"].createElement(\"div\", {\n        className: this.props.className,\n        id: this.containerId\n      });\n    }\n  }]);\n\n  return ReactFC;\n}(_react[\"default\"].Component);\n\nvar _default = ReactFC;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}